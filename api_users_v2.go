/*
OneLogin API

OpenAPI Specification for OneLogin

API version: 3.1.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onelogin

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// UsersV2ApiService UsersV2Api service
type UsersV2ApiService service

type ApiCreateUser2Request struct {
	ctx context.Context
	ApiService *UsersV2ApiService
	mappings *string
	validatePolicy *bool
	user *User
}

// Controls how mappings will be applied to the user on creation. Defaults to async.
func (r ApiCreateUser2Request) Mappings(mappings string) ApiCreateUser2Request {
	r.mappings = &mappings
	return r
}

// Will passwords validate against the User Policy? Defaults to true.
func (r ApiCreateUser2Request) ValidatePolicy(validatePolicy bool) ApiCreateUser2Request {
	r.validatePolicy = &validatePolicy
	return r
}

func (r ApiCreateUser2Request) User(user User) ApiCreateUser2Request {
	r.user = &user
	return r
}

func (r ApiCreateUser2Request) Execute() (*User, *http.Response, error) {
	return r.ApiService.CreateUser2Execute(r)
}

/*
CreateUser2 Create User

Create User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUser2Request
*/
func (a *UsersV2ApiService) CreateUser2(ctx context.Context) ApiCreateUser2Request {
	return ApiCreateUser2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersV2ApiService) CreateUser2Execute(r ApiCreateUser2Request) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersV2ApiService.CreateUser2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mappings != nil {
		parameterAddToQuery(localVarQueryParams, "mappings", r.mappings, "")
	}
	if r.validatePolicy != nil {
		parameterAddToQuery(localVarQueryParams, "validate_policy", r.validatePolicy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUser2Request struct {
	ctx context.Context
	ApiService *UsersV2ApiService
	userId int32
}

func (r ApiDeleteUser2Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUser2Execute(r)
}

/*
DeleteUser2 Delete User

Delete User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Set to the id of the user that you want to return.
 @return ApiDeleteUser2Request
*/
func (a *UsersV2ApiService) DeleteUser2(ctx context.Context, userId int32) ApiDeleteUser2Request {
	return ApiDeleteUser2Request{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersV2ApiService) DeleteUser2Execute(r ApiDeleteUser2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersV2ApiService.DeleteUser2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUser2Request struct {
	ctx context.Context
	ApiService *UsersV2ApiService
	userId int32
}

func (r ApiGetUser2Request) Execute() (*User, *http.Response, error) {
	return r.ApiService.GetUser2Execute(r)
}

/*
GetUser2 Get User

Get User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Set to the id of the user that you want to return.
 @return ApiGetUser2Request
*/
func (a *UsersV2ApiService) GetUser2(ctx context.Context, userId int32) ApiGetUser2Request {
	return ApiGetUser2Request{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return User
func (a *UsersV2ApiService) GetUser2Execute(r ApiGetUser2Request) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersV2ApiService.GetUser2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserApps2Request struct {
	ctx context.Context
	ApiService *UsersV2ApiService
	userId int32
	ignoreVisibility *bool
}

// Defaults to &#x60;false&#x60;. When &#x60;true&#x60; will show all apps that are assigned to a user regardless of their portal visibility setting.
func (r ApiGetUserApps2Request) IgnoreVisibility(ignoreVisibility bool) ApiGetUserApps2Request {
	r.ignoreVisibility = &ignoreVisibility
	return r
}

func (r ApiGetUserApps2Request) Execute() ([]GetUserApps200ResponseInner, *http.Response, error) {
	return r.ApiService.GetUserApps2Execute(r)
}

/*
GetUserApps2 Get User Apps

Get User Apps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Set to the id of the user that you want to return.
 @return ApiGetUserApps2Request
*/
func (a *UsersV2ApiService) GetUserApps2(ctx context.Context, userId int32) ApiGetUserApps2Request {
	return ApiGetUserApps2Request{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []GetUserApps200ResponseInner
func (a *UsersV2ApiService) GetUserApps2Execute(r ApiGetUserApps2Request) ([]GetUserApps200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetUserApps200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersV2ApiService.GetUserApps2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2/users/{user_id}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreVisibility != nil {
		parameterAddToQuery(localVarQueryParams, "ignore_visibility", r.ignoreVisibility, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsers2Request struct {
	ctx context.Context
	ApiService *UsersV2ApiService
	limit *int32
	page *int32
	cursor *string
	createdSince *string
	createdUntil *string
	updatedSince *string
	updatedUntil *string
	lastLoginSince *string
	lastLoginUntil *string
	firstname *string
	lastname *string
	email *string
	username *string
	samaccountname *string
	directoryId *int32
	externalId *string
	userIds *string
	customAttributesAttributeName *string
	fields *string
}

// How many items to return at one time (max 100)
func (r ApiListUsers2Request) Limit(limit int32) ApiListUsers2Request {
	r.limit = &limit
	return r
}

// The page number of results to return.
func (r ApiListUsers2Request) Page(page int32) ApiListUsers2Request {
	r.page = &page
	return r
}

// Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.
func (r ApiListUsers2Request) Cursor(cursor string) ApiListUsers2Request {
	r.cursor = &cursor
	return r
}

// An ISO8601 timestamp value that returns all users created after a given date &amp; time.
func (r ApiListUsers2Request) CreatedSince(createdSince string) ApiListUsers2Request {
	r.createdSince = &createdSince
	return r
}

// An ISO8601 timestamp value that returns all users created before a given date &amp; time.
func (r ApiListUsers2Request) CreatedUntil(createdUntil string) ApiListUsers2Request {
	r.createdUntil = &createdUntil
	return r
}

// An ISO8601 timestamp value that returns all users updated after a given date &amp; time.
func (r ApiListUsers2Request) UpdatedSince(updatedSince string) ApiListUsers2Request {
	r.updatedSince = &updatedSince
	return r
}

// An ISO8601 timestamp value that returns all users updated before a given date &amp; time.
func (r ApiListUsers2Request) UpdatedUntil(updatedUntil string) ApiListUsers2Request {
	r.updatedUntil = &updatedUntil
	return r
}

// An ISO8601 timestamp value that returns all users that logged in after a given date &amp; time.
func (r ApiListUsers2Request) LastLoginSince(lastLoginSince string) ApiListUsers2Request {
	r.lastLoginSince = &lastLoginSince
	return r
}

// An ISO8601 timestamp value that returns all users that logged in before a given date &amp; time.
func (r ApiListUsers2Request) LastLoginUntil(lastLoginUntil string) ApiListUsers2Request {
	r.lastLoginUntil = &lastLoginUntil
	return r
}

// The first name of the user
func (r ApiListUsers2Request) Firstname(firstname string) ApiListUsers2Request {
	r.firstname = &firstname
	return r
}

// The last name of the user
func (r ApiListUsers2Request) Lastname(lastname string) ApiListUsers2Request {
	r.lastname = &lastname
	return r
}

// The email address of the user
func (r ApiListUsers2Request) Email(email string) ApiListUsers2Request {
	r.email = &email
	return r
}

// The username for the user
func (r ApiListUsers2Request) Username(username string) ApiListUsers2Request {
	r.username = &username
	return r
}

// The AD login name for the user
func (r ApiListUsers2Request) Samaccountname(samaccountname string) ApiListUsers2Request {
	r.samaccountname = &samaccountname
	return r
}

func (r ApiListUsers2Request) DirectoryId(directoryId int32) ApiListUsers2Request {
	r.directoryId = &directoryId
	return r
}

// An external identifier that has been set on the user
func (r ApiListUsers2Request) ExternalId(externalId string) ApiListUsers2Request {
	r.externalId = &externalId
	return r
}

// A comma separated list of OneLogin User IDs
func (r ApiListUsers2Request) UserIds(userIds string) ApiListUsers2Request {
	r.userIds = &userIds
	return r
}

// The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.
func (r ApiListUsers2Request) CustomAttributesAttributeName(customAttributesAttributeName string) ApiListUsers2Request {
	r.customAttributesAttributeName = &customAttributesAttributeName
	return r
}

// Optional. Comma delimited list of fields to return.
func (r ApiListUsers2Request) Fields(fields string) ApiListUsers2Request {
	r.fields = &fields
	return r
}

func (r ApiListUsers2Request) Execute() ([]User, *http.Response, error) {
	return r.ApiService.ListUsers2Execute(r)
}

/*
ListUsers2 List Users

Get a list of users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListUsers2Request
*/
func (a *UsersV2ApiService) ListUsers2(ctx context.Context) ApiListUsers2Request {
	return ApiListUsers2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []User
func (a *UsersV2ApiService) ListUsers2Execute(r ApiListUsers2Request) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersV2ApiService.ListUsers2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.page != nil {
		parameterAddToQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.cursor != nil {
		parameterAddToQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.createdSince != nil {
		parameterAddToQuery(localVarQueryParams, "created_since", r.createdSince, "")
	}
	if r.createdUntil != nil {
		parameterAddToQuery(localVarQueryParams, "created_until", r.createdUntil, "")
	}
	if r.updatedSince != nil {
		parameterAddToQuery(localVarQueryParams, "updated_since", r.updatedSince, "")
	}
	if r.updatedUntil != nil {
		parameterAddToQuery(localVarQueryParams, "updated_until", r.updatedUntil, "")
	}
	if r.lastLoginSince != nil {
		parameterAddToQuery(localVarQueryParams, "last_login_since", r.lastLoginSince, "")
	}
	if r.lastLoginUntil != nil {
		parameterAddToQuery(localVarQueryParams, "last_login_until", r.lastLoginUntil, "")
	}
	if r.firstname != nil {
		parameterAddToQuery(localVarQueryParams, "firstname", r.firstname, "")
	}
	if r.lastname != nil {
		parameterAddToQuery(localVarQueryParams, "lastname", r.lastname, "")
	}
	if r.email != nil {
		parameterAddToQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.username != nil {
		parameterAddToQuery(localVarQueryParams, "username", r.username, "")
	}
	if r.samaccountname != nil {
		parameterAddToQuery(localVarQueryParams, "samaccountname", r.samaccountname, "")
	}
	if r.directoryId != nil {
		parameterAddToQuery(localVarQueryParams, "directory_id", r.directoryId, "")
	}
	if r.externalId != nil {
		parameterAddToQuery(localVarQueryParams, "external_id", r.externalId, "")
	}
	if r.userIds != nil {
		parameterAddToQuery(localVarQueryParams, "user_ids", r.userIds, "")
	}
	if r.customAttributesAttributeName != nil {
		parameterAddToQuery(localVarQueryParams, "custom_attributes.{attribute_name}", r.customAttributesAttributeName, "")
	}
	if r.fields != nil {
		parameterAddToQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUser2Request struct {
	ctx context.Context
	ApiService *UsersV2ApiService
	userId int32
	mappings *string
	validatePolicy *bool
	user *User
}

// Controls how mappings will be applied to the user on creation. Defaults to async.
func (r ApiUpdateUser2Request) Mappings(mappings string) ApiUpdateUser2Request {
	r.mappings = &mappings
	return r
}

// Will passwords validate against the User Policy? Defaults to true.
func (r ApiUpdateUser2Request) ValidatePolicy(validatePolicy bool) ApiUpdateUser2Request {
	r.validatePolicy = &validatePolicy
	return r
}

func (r ApiUpdateUser2Request) User(user User) ApiUpdateUser2Request {
	r.user = &user
	return r
}

func (r ApiUpdateUser2Request) Execute() (*User, *http.Response, error) {
	return r.ApiService.UpdateUser2Execute(r)
}

/*
UpdateUser2 Update User

Update User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Set to the id of the user that you want to return.
 @return ApiUpdateUser2Request
*/
func (a *UsersV2ApiService) UpdateUser2(ctx context.Context, userId int32) ApiUpdateUser2Request {
	return ApiUpdateUser2Request{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return User
func (a *UsersV2ApiService) UpdateUser2Execute(r ApiUpdateUser2Request) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersV2ApiService.UpdateUser2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mappings != nil {
		parameterAddToQuery(localVarQueryParams, "mappings", r.mappings, "")
	}
	if r.validatePolicy != nil {
		parameterAddToQuery(localVarQueryParams, "validate_policy", r.validatePolicy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
